% The predicate has a subject and an object
rule pred_nsubj_obj(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		V[cat=VERB, lemma=lex.lemma];
		nsubj_rel: V -[nsubj]-> NSUBJ;
		obj_rel: V -[obj]-> OBJ;
	}
	commands {
		del_edge nsubj_rel;
		del_edge obj_rel;
		add_edge V -[lex.doer]-> NSUBJ;
		add_edge V -[lex.patient]-> OBJ;
		V.doer = lex.doer;
		V.patient = lex.patient;
		V.concept = lex.concept;
		NSUBJ.concept = NSUBJ.form;
		OBJ.concept = OBJ.form;
	}
}

% The predicate has an object
rule pred_obj(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		V[cat=VERB, lemma=lex.lemma];
		obj_rel: V -[obj]-> OBJ;
	}
	commands {
		del_edge obj_rel;
		add_edge V -[lex.patient]-> OBJ;
		V.patient = lex.patient;
		V.concept = lex.concept;
		OBJ.concept = OBJ.form;
	}
}

% The predicate has a subject and an object
rule pred_nsubj(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		V[cat=VERB, lemma=lex.lemma];
		nsubj_rel: V -[nsubj]-> NSUBJ;
	}
	commands {
		del_edge nsubj_rel;
		add_edge V -[lex.doer]-> NSUBJ;
		V.doer = lex.doer;
		V.concept = lex.concept;
		NSUBJ.concept = NSUBJ.form;
	}
}

%% Noun which has an amod and has not been changed by noun_amod_arg_of
%rule noun_amod2{
%	pattern{
%		N[cat=NOUN];
%		amod_rel: N -[amod]-> A;
%	}
%	commands{
%
%	}
%}

% Noun which has an amod and has not been changed by noun_amod_arg_of
rule noun_amod{
	pattern{
		N[cat=NOUN];
		amod_rel: N -[amod]-> A;
	}
	commands{
		del_edge amod_rel;
		add_edge N -[mod]-> A;
		N.concept = N.form;
		A.concept = A.form;
	}
}

% A clausal complement of a verb/adverb (i.e. predicate) that is not a copula construction. 
rule ccomp_verbadv_notcop(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern{
		GOV[lemma=lex.lemma, upos=VERB|ADV];
		ccomp_rel: GOV -[ccomp]-> DEP;
	}
	without{
		GOV[lemma="be"];
		} %exclude all copula constructions
	commands{
		GOV.patient = lex.patient;
		del_edge ccomp_rel;
	}
}

%% K-to-complete | A clausal complement involving an equational copula construction. !to figure out how to assign have-degree-91 ARG0 to ARG6
%rule ccomp_copula_equational(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
%	pattern{
%		
%	}
%	commands{
%		add_node X; X.concept = "have-degree-91";
%		add_edge GOV-[]->DEP;
%		del_edge ccomp_rel;
%
%	}
%}

%% K-to-double check | A clausal complement with a copula construction that is not equational. !to figure out how to assign have-degree-91 ARG0 to ARG6
%rule ccomp_copula_nonequational(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
%	pattern{
%		
%	}
%	commands{
%		add_edge DEP -[lex.doer]-> GOV;
%		DEP.doer = lex.doer;
%		del_edge ccomp_rel;
%
%	}
%}

% An iobj relation whose dependent is a nominal and whose governor is in the predicate lexicon. 
rule iobj_nom_lex(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
    pattern{
		GOV [lemma = lex.lemma];
      	DEP [upos=NOUN|PROPN|PRON];
      	iobj_rel: GOV -[iobj]-> DEP;
	  }
    commands{ 
		GOV.patient = lex.patient;
		del_edge iobj_rel; 
	}
}

% An iobj relation whose dependent is a nominal and whose governor is in not the predicate lexicon. 
rule iobj_nom_notlex{
    pattern{
      	DEP [upos=NOUN|PROPN|PRON];
      	iobj_rel: GOV -[iobj]-> DEP;
	  }
    commands{ 
		add_edge GOV -[beneficiary]-> DEP;
		del_edge iobj_rel; 
	}
}

%% K-to-complete | An iobj relation whose dependent is a not nominal and whose governor is/is not in the predicate lexicon. 
%% [This means that the dependent should be the head of another AMR subgraph...]
%rule iobj_notnom_notlex{
%    pattern{
%      	DEP [upos=NOUN|PROPN|PRON];
%      	iobj_rel: GOV -[iobj]-> DEP;
%	  }
%    commands{ 
%		add_edge GOV -[beneficiary]-> DEP;
%		del_edge iobj_rel; 
%	}
%}

% Remove DET tags with a lemma "a", "an" or "the"
rule remove_det{
	pattern{
		D[cat=DET, lemma="the"|"a"|"an"];
		det_rel: X -[det]-> D;
	}
	commands{
		del_node D;
	}
}

%If DET's lemma is "all", make it a :mod
rule det_as_all{
	pattern{
		D[cat=DET, lemma="all"];
		det_rel: X -[det]-> D;
	}
	commands{
		del_edge det_rel;
		add_edge X -[mod]-> D;
	}
}

% If DET is a personal pronoun, transform that to :poss
% Possesive determiners are given the tag DEP, butthe relation nmod. However, we need
% to account for the cases where they are given the relation dep too because
% this may happen often across the data.
rule det_as_pers_pron{
	pattern{
		D[cat=DET, upos=PRON];
		det_rel: X -[det]-> D;
	}
	without{
		D[lemma="which"];
	}
	commands{
		del_edge det_rel;
		add_edge X -[poss]-> D;
	}
}

rule remove_punct{
	pattern{
		P[cat=PUNCT];
	}
	commands{
		del_node P;
	}
}

rule remove_root_rel{
	pattern{
		root_rel: X -[root]-> Y;
	}
	commands{
		del_edge root_rel;
		del_node X;
	}
}

% Transform nmod or nmod:poss relation to a poss relation
rule nmod{
	pattern{
		nmod_rel: GOV -[nmod|nmod:poss]-> DEP;
	}
	commands{
		del_edge nmod_rel;
		add_edge GOV -[poss]-> DEP;
	}
}

% If there are more than members in a conjunction, add an :op relation to the middle ones
% This rule needs to be applied once for each middle element
rule cc_to_op_morethan2{
	pattern{
		LAST -[cc]-> AND;
		FIRST -[conj]-> LAST;
		conj_rel: FIRST -[conj]-> MID;
	}
	commands{
		del_edge conj_rel;
		add_edge AND -[op]-> MID;
	}
}

% If there are a cc and a conj relations but no middle relations (only two members in a conjuction)
% then transform both the first and last element in :op
rule cc_to_op{
	pattern{
		cc_rel: LAST -[cc]-> AND;
		conj_rel: FIRST -[conj]-> LAST;
	}
	without{
		FIRST -[conj]-> MID;
	}
	commands{
		del_edge conj_rel;
		add_edge AND -[op]-> FIRST;
		del_edge cc_rel;
		add_edge AND -[op]-> LAST;
	}
}

%Add a concept to each word
rule add_concept{
	pattern{
		N [lemma];
	}
	without{
		N [concept];
	}
	commands{
		%N.concept = "dummyConcept";
		N.concept = N.lemma;
	}
}


% Add the doer role for nodes with such an attribute.  
rule add_doerARG0(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		doer_rel: GOV -[lex.doer]-> DEP;
		GOV[doer="ARG0"];
	}
	commands {
		add_edge GOV -[ARG0]-> DEP;
		del_edge doer_rel;
	}
}

% Add the doer role for nodes with such an attribute. 
rule add_doerARG1(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		doer_rel: GOV -[lex.doer]-> DEP;
		GOV[doer="ARG1"];
	}
	commands {
		add_edge GOV -[ARG1]-> DEP;
		del_edge doer_rel;
	}
}

% Add the doer role for nodes with such an attribute. 
rule add_doerARG2(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		doer_rel: GOV -[lex.doer]-> DEP;
		GOV[doer="ARG2"];
	}
	commands {
		add_edge GOV -[ARG2]-> DEP;
		del_edge doer_rel;
	}
}

% Add the doer role for nodes with such an attribute. 
rule add_doerARG3(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		doer_rel: GOV -[lex.doer]-> DEP;
		GOV[doer="ARG3"];
	}
	commands {
		add_edge GOV -[ARG3]-> DEP;
		del_edge doer_rel;
	}
}

% Add the doer role for nodes with such an attribute. 
rule add_doerARG4(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		doer_rel: GOV -[lex.doer]-> DEP;
		GOV[doer="ARG4"];
	}
	commands {
		add_edge GOV -[ARG4]-> DEP;
		del_edge doer_rel;
	}
}

% Add the patient role for nodes with such an attribute. 
rule add_patientARG0(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		patient_rel: GOV -[lex.patient]-> DEP;
		GOV[patient="ARG0"];
	}
	commands {
		add_edge GOV -[ARG0]-> DEP;
		del_edge patient_rel;
	}
}

% Add the patient role for nodes with such an attribute. 
rule add_patientARG1(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		patient_rel: GOV -[lex.patient]-> DEP;
		GOV[patient="ARG1"];
	}
	commands {
		add_edge GOV -[ARG1]-> DEP;
		del_edge patient_rel;
	}
}

% Add the patient role for nodes with such an attribute. 
rule add_patientARG2(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		patient_rel: GOV -[lex.patient]-> DEP;
		GOV[patient="ARG2"];
	}
	commands {
		add_edge GOV -[ARG2]-> DEP;
		del_edge patient_rel;
	}
}

% Add the patient role for nodes with such an attribute. 
rule add_patientARG3(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		patient_rel: GOV -[lex.patient]-> DEP;
		GOV[patient="ARG3"];
	}
	commands {
		add_edge GOV -[ARG3]-> DEP;
		del_edge patient_rel;
	}
}

% Add the patient role for nodes with such an attribute. 
rule add_patientARG4(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		patient_rel: GOV -[lex.patient]-> DEP;
		GOV[patient="ARG4"];
	}
	commands {
		add_edge GOV -[ARG4]-> DEP;
		del_edge patient_rel;
	}
}

% The predicate has a nsubj relation with a :pass subtag
rule pred_nsubjpass(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		GOV[lemma=lex.lemma];
		nsubj_rel: GOV -[nsubj:pass]-> NSUBJPASS;
	}
	commands {
		del_edge nsubj_rel;
		add_edge GOV -[lex.patient]-> NSUBJPASS;
		GOV.patient = lex.patient;
		GOV.concept = lex.concept;
		NSUBJPASS.concept = NSUBJPASS.form;
	}
}

% The predicate has a nsubj relation with a :pass subtag as well as a obj relation
rule pred_nsubjpass_obj(lex from "lexicons/subcat/verb_nsubj_obj.lp"){
	pattern {
		GOV[lemma=lex.lemma];
		nsubj_rel: GOV -[nsubj:pass]-> NSUBJPASS;
		obj_rel: GOV -[obj]-> OBJ;
	}
	commands {
		del_edge nsubj_rel;
		del_edge obj_rel;
		GOV.doer = lex.doer;
		GOV.patient = lex.patient;
		GOV.concept = lex.concept;
		NSUBJPASS.concept = NSUBJPASS.form;
		OBJ.concept = OBJ.form;
	}
}

%remove aux:pass relation when the predicate has an nsubj:pass relation too
rule remove_aux_pass {
	pattern {
		aux_pass_rel: GOV -[aux:pass]-> DEP;
		nsubj_pass_rel: GOV -[nsubj:pass]-> DEP2;
	}
	commands {
		del_node DEP;
	}
}